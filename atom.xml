<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>混沌猫的窝</title>
  
  
  <link href="https://chaoslawful.info/atom.xml" rel="self"/>
  
  <link href="https://chaoslawful.info/"/>
  <updated>2022-05-06T16:03:25.117Z</updated>
  <id>https://chaoslawful.info/</id>
  
  <author>
    <name>chaoslawful</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CLIP+VQGAN 风格关键词示例</title>
    <link href="https://chaoslawful.info/2022/05/06/clip-vqgan-keywords/"/>
    <id>https://chaoslawful.info/2022/05/06/clip-vqgan-keywords/</id>
    <published>2022-05-06T15:41:00.000Z</published>
    <updated>2022-05-06T16:03:25.117Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/alembics/disco-diffusion">Disco Diffusion</a> 是最近比较火的多模态 AI 图像生成系统，可以通过英文文本描述直接生成质量还不错的画作。该系统生成图像的风格受到若干关键词的强烈影响，因此社区中一个热点就是寻找各种风格独特的关键词组合。imgur 上有位网友 @kingdomakrillic 整理了一份CLIP + VQGAN 生成图像的风格关键词示例，基本上可以直接套用到 Disco Diffusion 系统中，非常有用！</p><span id="more"></span><p><img src="/images/2022-05-06/clip_vqgan_keywords1.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords2.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords3.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords4.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords5.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords6.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords7.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords8.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords9.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords10.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords11.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords12.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords13.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords14.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords15.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords16.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords17.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords18.jpg" alt="" /><img src="/images/2022-05-06/clip_vqgan_keywords19.jpg" alt="" /></p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://imgur.com/a/SnSIQRu">CLIP + VQGAN keyword comparison by @kingdomakrillic</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/alembics/disco-diffusion&quot;&gt;Disco Diffusion&lt;/a&gt; 是最近比较火的多模态 AI 图像生成系统，可以通过英文文本描述直接生成质量还不错的画作。
该系统生成图像的风格受到若干关键词的强烈影响，因此社区中一个热点就是寻找各种风格独特的关键词组合。imgur 上有位网友 @kingdomakrillic 整理了一份
CLIP + VQGAN 生成图像的风格关键词示例，基本上可以直接套用到 Disco Diffusion 系统中，非常有用！&lt;/p&gt;</summary>
    
    
    
    
    <category term="CLIP" scheme="https://chaoslawful.info/tags/CLIP/"/>
    
    <category term="VQGAN" scheme="https://chaoslawful.info/tags/VQGAN/"/>
    
    <category term="Disco Diffusion" scheme="https://chaoslawful.info/tags/Disco-Diffusion/"/>
    
  </entry>
  
  <entry>
    <title>Win10 家庭版上安装 Hyper-V 的方法</title>
    <link href="https://chaoslawful.info/2021/04/10/win10-home-hyperv-install/"/>
    <id>https://chaoslawful.info/2021/04/10/win10-home-hyperv-install/</id>
    <published>2021-04-10T15:41:27.000Z</published>
    <updated>2022-05-06T16:08:29.357Z</updated>
    
    <content type="html"><![CDATA[<p>WSL2 需要打开 Hyper-V 的支持，而 Win10 家庭版上没有 Hyper-V 完整组件，有 2 种方法可以开启 Hyper-V：</p><span id="more"></span><ol><li>在管理员权限的 PowerShell 中执行如下命令行即可开启 Hyper-V 服务：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure><ol><li>将以下代码另存为 <code>hyper-v.bat</code>，以管理员权限执行即可安装完整的 Hyper-V 组件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> <span class="string">&quot;%~dp0&quot;</span></span><br><span class="line"><span class="built_in">dir</span> /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hv.txt</span><br><span class="line"><span class="keyword">for</span> /f %%i <span class="keyword">in</span> (<span class="string">&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;</span>) <span class="keyword">do</span> dism /online /norestart /add-package:<span class="string">&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span></span><br><span class="line">del hv.txt</span><br><span class="line">dism /online /enable-feature /featurename:Microsoft-Hyper-V -All /LimitAccess /ALL</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li><a href="https://docs.microsoft.com/en-us/answers/questions/29175/installation-of-hyper-v-on-windows-10-home.html">https://docs.microsoft.com/en-us/answers/questions/29175/installation-of-hyper-v-on-windows-10-home.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;WSL2 需要打开 Hyper-V 的支持，而 Win10 家庭版上没有 Hyper-V 完整组件，有 2 种方法可以开启 Hyper-V：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Virtualization" scheme="https://chaoslawful.info/tags/Virtualization/"/>
    
    <category term="WSL" scheme="https://chaoslawful.info/tags/WSL/"/>
    
    <category term="Win10" scheme="https://chaoslawful.info/tags/Win10/"/>
    
    <category term="Hyper-V" scheme="https://chaoslawful.info/tags/Hyper-V/"/>
    
  </entry>
  
  <entry>
    <title>在 WSL2 环境中使用 Win10 宿主系统中代理的方法</title>
    <link href="https://chaoslawful.info/2021/04/08/wsl-2-how-to-use-win10-proxy/"/>
    <id>https://chaoslawful.info/2021/04/08/wsl-2-how-to-use-win10-proxy/</id>
    <published>2021-04-08T12:28:51.000Z</published>
    <updated>2022-05-06T16:09:17.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>Win10 中 WSL2 环境是一个 HyperV 管理的独立容器，其网络相对宿主系统独立，不像 WSL1 环境那样是和宿主系统网卡直接桥接起来的。WSL2 这样的架构虽然运行效率提高不少，但却无法像 WSL1 那样能直接使用宿主系统提供的代理服务，造成了不少麻烦。</p><span id="more"></span><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><p>解决办法很简单，只要允许代理服务为非 <code>localhost</code> 来源地址服务，然后直接使用宿主系统的 IP 地址就能访问到代理了。以 Ubuntu WSL2 环境访问 Shadowsocks 代理为例，步骤如下：</p><ol><li>允许 Shadowsocks 服务非本地来源地址：<img src="/images/wsl2-use-win10-proxy/ss-config.png" alt="" /></li><li>在 <code>.bashrc</code> 中加入如下的函数方便打开/关闭代理（假设宿主系统 IP 地址为 <code>192.168.175.173</code>，Shadowsocks SOCKS5 代理在 <code>1080</code> 端口）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">proxy</span></span> () &#123;</span><br><span class="line">    <span class="comment"># 设置全局代理服务器环境变量</span></span><br><span class="line">    <span class="built_in">export</span> ALL_PROXY=<span class="string">&quot;socks5://192.168.175.173:1080&quot;</span></span><br><span class="line">    <span class="built_in">export</span> all_proxy=<span class="string">&quot;socks5://192.168.175.173:1080&quot;</span></span><br><span class="line">    <span class="comment"># 给 apt-get 增加代理配置</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;Acquire::http::Proxy \&quot;http://192.168.175.173:1080\&quot;;&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/apt.conf &gt; /dev/null</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;Acquire::https::Proxy \&quot;http://192.168.175.173:1080\&quot;;&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/apt.conf &gt; /dev/null</span><br><span class="line">    <span class="comment"># 提示用户当前出口地址</span></span><br><span class="line">    curl myip.ipip.net</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">noproxy</span></span> () &#123;</span><br><span class="line">    <span class="comment"># 清除全局代理服务器环境变量</span></span><br><span class="line">    <span class="built_in">unset</span> ALL_PROXY</span><br><span class="line">    <span class="built_in">unset</span> all_proxy</span><br><span class="line">    <span class="comment"># 清除 apt-get 代理设置</span></span><br><span class="line">    sudo sed -i -e <span class="string">&#x27;/Acquire::http::Proxy/d&#x27;</span> /etc/apt/apt.conf</span><br><span class="line">    sudo sed -i -e <span class="string">&#x27;/Acquire::https::Proxy/d&#x27;</span> /etc/apt/apt.conf</span><br><span class="line">    <span class="comment"># 提示用户当前出口地址</span></span><br><span class="line">    curl myip.ipip.net</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在终端上就可直接用 <code>proxy</code> 开启代理，<code>noproxy</code> 关闭代理。</p><ol><li>对于那些不使用全局代理服务器环境变量的应用，可以安装 <code>proxychains</code> 来实现拦截其网络通信强制走代理的目的：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install proxychains tor</span><br></pre></td></tr></table></figure><p>安装完毕后，向 <code>/etc/proxychains.conf</code> 增加如下配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[ProxyList]</span></span><br><span class="line">socks5 192.168.175.173 1080</span><br></pre></td></tr></table></figure><p>然后就能用 <code>proxychains &lt;app_path&gt; &lt;cmdline&gt;</code> 的形式强制应用使用代理了。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/144647249">https://zhuanlan.zhihu.com/p/144647249</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;Win10 中 WSL2 环境是一个 HyperV 管理的独立容器，其网络相对宿主系统独立，不像 WSL1 环境那样是和宿主系统网卡直接桥接起来的。WSL2 这样的架构虽然运行效率提高不少，但却无法像 WSL1 那样能直接使用宿主系统提供的代理服务，造成了不少麻烦。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Networking" scheme="https://chaoslawful.info/tags/Networking/"/>
    
    <category term="WSL" scheme="https://chaoslawful.info/tags/WSL/"/>
    
    <category term="Win10" scheme="https://chaoslawful.info/tags/Win10/"/>
    
  </entry>
  
  <entry>
    <title>自动配置网线直连数据传输方案</title>
    <link href="https://chaoslawful.info/2021/04/08/null-modem-auto-conf/"/>
    <id>https://chaoslawful.info/2021/04/08/null-modem-auto-conf/</id>
    <published>2021-04-08T06:21:05.000Z</published>
    <updated>2022-05-06T16:09:32.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>在很多场景下（手头没有 U 盘、某台电脑 USB 口不可用或没有足够权限安装存储设备驱动等等），我们都需要通过网线直连的方式在两台电脑之间传输数据，这样就要求正确地将两台电脑设置为同一子网下的不同静态 IP。对于电脑知识较为丰富的用户来说此设置过程非常简单，但对于一般用户来说就比较困难了，此时就希望通过程序自动配置好这种网络环境。</p><span id="more"></span><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>这里主要针对 Windows XP 系统自动配置进行分析，因 Vista 以上版本系统已经有了 <code>zeroconf</code> 的实现，有现成的解决方案可用。</p><p>网卡地址要么是静态设置，要么是动态 DHCP 分配的。对于静态设置 IP 的情况，拔掉再插上网线后 Windows 系统会监测到媒介状态变化，并自动发送若干源 MAC 为对应网卡 MAC，源/目标 IP 均为当前网卡静态设置 IP 的 ARP 包（称为 Gratuitous ARP 包，用来向子网内其他机器或网关主张自己的静态 IP 所有权），若将网线另一侧机器的 IP 设置为同一子网内的地址，两台机器就能正常通讯了。</p><p><img src="/images/2015-07-21/static-ip-pcap.png" alt="Static IP Capture" title="静态 IP 抓包结果" /></p><p>对于动态 DHCP 分配的情况，拔掉再插上网线后 Windows 系统会自动发送 DHCP 相关请求，要求可能存在的 DHCP 服务器分配 IP，若在网线另一侧机器上运行 DHCP 服务，即可自动设置双机 IP 在同一子网中，也能正常通讯。</p><p><img src="/images/2015-07-21/dhcp-ip-pcap.png" alt="DHCP IP Capture" title="动态 DHCP 抓包结果" /></p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>参考实现程序<a href="https://github.com/chaoslawful/nullconf">在此</a>。该程序使用 <code>pcapy</code> 模块操作 <code>WinPCAP</code> 在指定网卡（Windows 环境下通过 <code>wmi</code> 模块自动获得首个可用的有线网卡）上监听数据包，通过 <code>impacket</code> 模块解析后根据数据包特征决定使用静态还是动态配置逻辑，最后用 OS 相关方法设置本地监听的有线网卡 IP 后（Windows 环境下通过 <code>wmi</code> 模块实现）完成双机 IP 配置。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="http://timgolden.me.uk/python/wmi/tutorial.html">http://timgolden.me.uk/python/wmi/tutorial.html</a></li><li><a href="https://msdn.microsoft.com/en-us/library/bg126473(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/bg126473(v=vs.85).aspx</a></li><li><a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;在很多场景下（手头没有 U 盘、某台电脑 USB 口不可用或没有足够权限安装存储设备驱动等等），我们都需要通过网线直连的方式在两台电脑之间传输数据，这样就要求正确地将两台电脑设置为同一子网下的不同静态 IP。对于电脑知识较为丰富的用户来说此设置过程非常简单，但对于一般用户来说就比较困难了，此时就希望通过程序自动配置好这种网络环境。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://chaoslawful.info/tags/Linux/"/>
    
    <category term="Networking" scheme="https://chaoslawful.info/tags/Networking/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 18.04 LTS 中让桌面系统不占用 N 卡显存的方法</title>
    <link href="https://chaoslawful.info/2021/04/08/ubuntu-18-04-cuda-memory/"/>
    <id>https://chaoslawful.info/2021/04/08/ubuntu-18-04-cuda-memory/</id>
    <published>2021-04-08T06:18:54.000Z</published>
    <updated>2022-05-06T16:09:48.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>使用自己电脑的 N 卡进行 CUDA 加速时都希望能使用全部显存，但在 Ubuntu 18.04 LTS 中安装官方专有驱动后，如果用 nvidia-settings 将 PRIME profiles 设为 Nvidia，会让包括 X 桌面在内的所有图形加速功能都走 N 卡，会占用不少显存。若将 PRIME profiles 改为 Intel，N 卡驱动又不会被加载，无法使用 CUDA 加速。</p><span id="more"></span><h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3><p>PRIME profiles 是通过 <code>/usr/bin/prime-select</code> 命令完成切换的，PRIME profiles 设为 Intel 时该命令会生成一个驱动黑名单 <code>/lib/modprobe.d/blacklist-nvidia.conf</code>，修改该文件内容将如下几行注释掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blacklist nvidia</span><br><span class="line">blacklist nvidia-modeset</span><br><span class="line">alias nvidia off</span><br><span class="line">alias nvidia-modeset off</span><br></pre></td></tr></table></figure><p>logout 后重新 login 即可实现 X 桌面系统图形加速走集成显卡且 N 卡驱动正常加载的效果，可使用全部显存进行 CUDA 计算。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h3&gt;
&lt;p&gt;使用自己电脑的 N 卡进行 CUDA 加速时都希望能使用全部显存，但在 Ubuntu 18.04 LTS 中安装官方专有驱动后，如果用 nvidia-settings 将 PRIME profiles 设为 Nvidia，会让包括 X 桌面在内的所有图形加速功能都走 N 卡，会占用不少显存。若将 PRIME profiles 改为 Intel，N 卡驱动又不会被加载，无法使用 CUDA 加速。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://chaoslawful.info/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://chaoslawful.info/tags/Ubuntu/"/>
    
    <category term="CUDA" scheme="https://chaoslawful.info/tags/CUDA/"/>
    
    <category term="NVIDIA" scheme="https://chaoslawful.info/tags/NVIDIA/"/>
    
  </entry>
  
  <entry>
    <title>在 CentOS 6.x 下使用 gcc 4.9.x 的方法</title>
    <link href="https://chaoslawful.info/2021/04/08/2021-04-08-centos-6-inst-gcc-4-9/"/>
    <id>https://chaoslawful.info/2021/04/08/2021-04-08-centos-6-inst-gcc-4-9/</id>
    <published>2021-04-08T06:16:20.000Z</published>
    <updated>2022-05-06T16:09:02.347Z</updated>
    
    <content type="html"><![CDATA[<p>尝试在 CentOS 6.x 下编译使用 PyPy 5.x 时发现其生成的 interpreter.c 使用了 <code>__int128</code> 内置类型，但系统自带的 gcc 4.4.x 并不支持该类型，所以需要按如下步骤装一个 gcc 4.9.x：</p><span id="more"></span><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install centos-release-scl</span><br><span class="line">$ sudo yum install devtoolset-3-gcc devtoolset-3-binutils devtoolset-3-gcc-c++</span><br><span class="line"><span class="comment"># 用如下 scl 命令在新 gcc 环境中执行命令，这里执行的是 bash</span></span><br><span class="line">$ scl <span class="built_in">enable</span> devtoolset-3 bash</span><br><span class="line"><span class="comment"># 进入了新 gcc 环境的 shell，验证一下 gcc 版本</span></span><br><span class="line">$ gcc --version</span><br><span class="line">gcc (GCC) 4.9.2 20150212 (Red Hat 4.9.2-6)</span><br><span class="line">Copyright (C) 2014 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h3><ul><li><a href="http://superuser.com/questions/381160/how-to-install-gcc-4-7-x-4-8-x-on-centos">http://superuser.com/questions/381160/how-to-install-gcc-4-7-x-4-8-x-on-centos</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;尝试在 CentOS 6.x 下编译使用 PyPy 5.x 时发现其生成的 interpreter.c 使用了 &lt;code&gt;__int128&lt;/code&gt; 内置类型，但系统自带的 gcc 4.4.x 并不支持该类型，所以需要按如下步骤装一个 gcc 4.9.x：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://chaoslawful.info/tags/Linux/"/>
    
    <category term="GCC" scheme="https://chaoslawful.info/tags/GCC/"/>
    
  </entry>
  
  <entry>
    <title>Java 正则库 bug 一例</title>
    <link href="https://chaoslawful.info/2014/03/23/java-regex-bug/"/>
    <id>https://chaoslawful.info/2014/03/23/java-regex-bug/</id>
    <published>2014-03-23T14:16:00.000Z</published>
    <updated>2022-05-06T16:10:21.497Z</updated>
    
    <content type="html"><![CDATA[<p>一日同事尝试用 Java 正则库匹配某模式总是抛出 <code>String index out of range</code> 异常，百思不得其解。经过一番研究，得到了这样一个最小复现用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexBug</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;x&quot;</span>+Character.highSurrogate(<span class="number">0x10000</span>)+Character.lowSurrogate(<span class="number">0x10000</span>);</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(.)*xx&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(s);</span><br><span class="line">        <span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;matched&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>跟踪后发现这是 Java 正则库中的一个实现 bug，用例模式中的 <code>(.)*</code> 会被 Pattern 类解析为 GroupCurly 算子，而该算子内对应贪婪匹配模式的 <code>match0</code> 方法实现有误，当某次匹配不成功需要进行回溯时，其假定 <code>.</code> 匹配的任意字符都是相同长度而每次都减去了最后一次匹配成功的字符长度；然而 Java 内部使用 UTF-16 编码保存字符串，仅有 Unicode BMP 内的字符（即码点小于等于 U+FFFF 的字符）才能用单个 char 表示，Unicode SMP 内的字符（即码点大于 U+FFFF 的字符）都需要用 2 个替代码元表示 1 个字符，当匹配目标字符串中有 BMP/SMP 区字符混合存在的情况且匹配不成功时，回溯逻辑的字符等长假定就会失效，导致字符串下标计算出错而出现访问越界异常。不过同在 Pattern 类中表达非捕获重复算子的 Curly 就没有这个问题，如果将以上用例中的 <code>(.)*</code> 改为 <code>.*</code> 就一切正常了。</p><p>经过一番搜索，发现该 bug 已经在 2013-02-01 被人提交给 JDK buglist (<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8007395">见这里</a>) ，JDK 5~7 都受其影响，不过该 bug 已经在 JDK 8 中修复了。考虑到 Java 正则库实现细节非常不堪，也许还会有更多的坑在实践中被发现，定期关注一下 <code>java.util.regex</code> 相关的 bug (<a href="https://search.oracle.com/search/search?search_p_main_operator=all&amp;start=1&amp;group=bugs.sun.com&amp;q=java.util.regex">见这里</a>) 应该是个好主意……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一日同事尝试用 Java 正则库匹配某模式总是抛出 &lt;code&gt;String index out of range&lt;/code&gt; 异常，百思不得其解。经过一番研究，得到了这样一个最小复现用例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.regex.*;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;RegexBug&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;+Character.highSurrogate(&lt;span class=&quot;number&quot;&gt;0x10000&lt;/span&gt;)+Character.lowSurrogate(&lt;span class=&quot;number&quot;&gt;0x10000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;Pattern&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; Pattern.compile(&lt;span class=&quot;string&quot;&gt;&amp;quot;(.)*xx&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;Matcher&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; p.matcher(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(m.find()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;matched&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://chaoslawful.info/tags/Java/"/>
    
    <category term="regexp" scheme="https://chaoslawful.info/tags/regexp/"/>
    
  </entry>
  
  <entry>
    <title>IPython Notebook 转成 LaTeX 时的中文问题解决方案</title>
    <link href="https://chaoslawful.info/2014/03/10/ipython-notebook-latex-chinese-solution/"/>
    <id>https://chaoslawful.info/2014/03/10/ipython-notebook-latex-chinese-solution/</id>
    <published>2014-03-10T02:32:00.000Z</published>
    <updated>2022-05-06T16:10:49.557Z</updated>
    
    <content type="html"><![CDATA[<p>从 IPython 1.0 开始 IPython Notebook 就自带了 nbconvert 工具，可以将 notebook 转换为 HTML/LaTeX/Markdown/reStructure/Slides 等多种外部格式，以方便内容的快速重用。从内容展现的一致性上看，将 notebook 转成 LaTeX 再处理为 PDF 文件是表现最好的，因此使用频率也最高，然而当 notebook 中出现中文时，默认生成的 LaTeX 文件无法进行支持，会导致最终生成的 PDF 文件中中文部分都是空白。经过实验，对生成的 LaTeX 文件进行如下手工修改可以快速修正此问题：</p><span id="more"></span><ul><li>首先用 nbconvert 将 notebook 转为 LaTeX 文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython nbconvert --to latex example.ipynb</span><br></pre></td></tr></table></figure><ul><li>在生成的 LaTeX 文件里 <code>\documentclass</code> 行之后增加如下内容：</li></ul><pre>\usepackage{fontspec, xunicode, xltxtra}\usepackage[slantfont, boldfont]{xeCJK} % 允许斜体和粗体\setCJKmainfont{WenQuanYi Micro Hei} % 默认中文字体\setCJKmonofont{WenQuanYi Micro Hei Mono} % 中文等宽字体\setmainfont{TeX Gyre Pagella} % 英文衬线字体\setmonofont{Monaco} % 英文等宽字体\setsansfont{Trebuchet MS} % 英文无衬线字体\punctstyle{kaiming} % 开明式标点格式: 句末点号用全角, 其他半角</pre><ul><li>注释掉生成的 LaTeX 文件里 <code>\usepackage&#123;babel&#125;</code> 这一行</li><li>(可选) 将生成的 LaTeX 文件里 <code>\date&#123;...&#125;</code> 和 <code>\author&#123;...&#125;</code> 中的内容改为需要的日期和作者信息</li><li>最后用支持 UTF-8 的 <code>xelatex</code> 命令直接将修改后的 LaTeX 文件转为 PDF 即可：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex example.tex</span><br></pre></td></tr></table></figure><p>另外，最后转 PDF 时若出现类似这样的错误：</p><pre>> Runaway argument?> ! File ended while scanning use of @writefile.>> par> l.110 begin{document}</pre><p>可以直接删除 <code>*.aux</code> 文件再重新转换即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 IPython 1.0 开始 IPython Notebook 就自带了 nbconvert 工具，可以将 notebook 转换为 HTML/LaTeX/Markdown/reStructure/Slides 等多种外部格式，以方便内容的快速重用。从内容展现的一致性上看，将 notebook 转成 LaTeX 再处理为 PDF 文件是表现最好的，因此使用频率也最高，然而当 notebook 中出现中文时，默认生成的 LaTeX 文件无法进行支持，会导致最终生成的 PDF 文件中中文部分都是空白。经过实验，对生成的 LaTeX 文件进行如下手工修改可以快速修正此问题：&lt;/p&gt;</summary>
    
    
    
    
    <category term="IPython" scheme="https://chaoslawful.info/tags/IPython/"/>
    
    <category term="i18n" scheme="https://chaoslawful.info/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>OpenJDK 中查看 JIT 编译结果的方法</title>
    <link href="https://chaoslawful.info/2014/01/16/openjdk-inspect-jit-result/"/>
    <id>https://chaoslawful.info/2014/01/16/openjdk-inspect-jit-result/</id>
    <published>2014-01-16T11:35:00.000Z</published>
    <updated>2022-05-06T16:11:00.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>大家都知道 JVM 有 HotSpot 引擎可以对热代码路径进行有效的 JIT 优化，大幅度提升计算密集代码的性能，但 HotSpot 对自己编写的 Java 代码时进行了哪些 JIT 优化？优化后生成的 native code 长什么样？知道了这些信息之后，才能有的放矢地改进自己的代码。</p><span id="more"></span><h2 id="初步查看-jit-工作情况"><a class="markdownIt-Anchor" href="#初步查看-jit-工作情况"></a> 初步查看 JIT 工作情况</h2><p>以如下 Java 代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accumulator.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Accumulator</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">System.out.println(addAllSqrts(max));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">addAllSqrts</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line"><span class="type">double</span> <span class="variable">accum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">accum = addSqrt(accum, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> accum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">addSqrt</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + sqrt(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，我们只需要知道 JIT 内联函数是否满足自己的期望即可，可以用如下命令行达到这个目的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Accumulator.java</span><br><span class="line">java -XX:+PrintCompilation Accumulator 50000</span><br></pre></td></tr></table></figure><p>注意默认情况下一个方法至少要被调用 10k 次以上才可能被 JIT 优化，故这里运行时给出的循环参数也要大于该值，输出结果如下：</p><pre>     61    1             Accumulator::addSqrt (7 bytes)     62    2             Accumulator::sqrt (6 bytes)     67    3 %           Accumulator::addAllSqrts @ 4 (23 bytes)...</pre><p>各个数据列的含义分别为：</p><table><thead><tr><th style="text-align:left"><strong>列1</strong></th><th style="text-align:left"><strong>列2</strong></th><th style="text-align:left"><strong>列3</strong></th><th style="text-align:left"><strong>列4</strong></th><th style="text-align:left"><strong>列5</strong></th></tr></thead><tbody><tr><td style="text-align:left">自 JVM 启动到尝试优化的时间(ms)</td><td style="text-align:left">尝试优化的顺序(从 1 开始)</td><td style="text-align:left">特殊方法标识<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></td><td style="text-align:left">方法全名及生成代码长度</td><td style="text-align:left">若有 &quot;made not entrant&quot; 或 &quot;made zombie&quot; 字样就表明没有进行优化</td></tr></tbody></table><p>用如下命令行可以更多地了解内联优化的实际情况以及优化发生的级别：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining -XX:+TieredCompilation Accumulator 50000</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><pre>     50    1       3       java.lang.String::equals (81 bytes)     51    2       3       java.lang.Object::<init> (1 bytes)     53    3     n 0       java.lang.System::arraycopy (native)   (static)     53    4       3       java.lang.String::charAt (29 bytes)                              @ 18  java/lang/StringIndexOutOfBoundsException::<init> (not loaded)   not inlineable     54    6       3       java.lang.String::hashCode (55 bytes)     55    5       3       java.lang.String::indexOf (70 bytes)                              @ 66   java.lang.String::indexOfSupplementary (71 bytes)   callee is too large     56    7       3       java.lang.String::length (6 bytes)     59    8       3       java.lang.Math::min (11 bytes)     61    9       3       Accumulator::addSqrt (7 bytes)                              @ 2   Accumulator::sqrt (6 bytes)                                @ 2   java.lang.Math::sqrt (5 bytes)   intrinsic     62   10       3       Accumulator::sqrt (6 bytes)                              @ 2   java.lang.Math::sqrt (5 bytes)   intrinsic     64   11       4       Accumulator::addSqrt (7 bytes)...</pre><p>这里新增的第 3 列代表了优化发生的级别（Tier 0~4，其中 Tier 0 为 Interpreter，Tier 1~3 为 client 模式的优化策略，Tier 4 为 server 模式的优化策略）</p><h2 id="查看-jit-生成的汇编代码"><a class="markdownIt-Anchor" href="#查看-jit-生成的汇编代码"></a> 查看 JIT 生成的汇编代码</h2><p>为了更好地了解 JIT 优化效果，查看生成的 native code 是很有必要的，不过 OpenJDK 并没有自带反汇编插件 <code>hsdis-*.so</code> ，需要手工安装一下该插件。一般来说有这样几种安装方法：</p><ol><li>对于 Ubuntu 系的发行版，可以直接用命令 <code>sudo apt-get install libopenjdk-hsdis</code> 安装该插件</li><li>用别人从 OpenJDK 中扣出来的代码自行编译安装，具体见 <a href="https://github.com/drazzib/openjdk-hsdis">这里</a></li><li>按照 <a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">HotSpotInternals - PrintAssembly</a> 中的描述自己从 OpenJDK 源码树中编译</li></ol><p>安装完成后，即可用一下命令输出所有 JIT 后函数的 native code 汇编代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Accumulator 50000</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><pre>Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional outputLoaded disassembler from hsdis-amd64.soDecoding compiled method 0x00007ffd9905ee50:Code:[Disassembling for mach='i386:x86-64'][Entry Point][Verified Entry Point][Constants]  # {method} 'addSqrt' '(DI)D' in 'Accumulator'  # parm0:    xmm0:xmm0   = double  # parm1:    rsi       = int  #           [sp+0x20]  (sp of caller)  0x00007ffd9905ef80: sub    $0x18,%rsp  0x00007ffd9905ef87: mov    %rbp,0x10(%rsp)    ;*synchronization entry                                                ; - Accumulator::addSqrt@-1 (line 16)  0x00007ffd9905ef8c: vcvtsi2sd %esi,%xmm1,%xmm1  0x00007ffd9905ef90: vsqrtsd %xmm1,%xmm1,%xmm1  0x00007ffd9905ef94: vaddsd %xmm1,%xmm0,%xmm0  ;*dadd                                                ; - Accumulator::addSqrt@5 (line 16)  0x00007ffd9905ef98: add    $0x10,%rsp  0x00007ffd9905ef9c: pop    %rbp  0x00007ffd9905ef9d: test   %eax,0xc5f905d(%rip)        # 0x00007ffda5658000                                                ;   {poll_return}  0x00007ffd9905efa3: retq  0x00007ffd9905efa4: hlt  0x00007ffd9905efa5: hlt...</pre><p>还可以增加选项 <code>-XX:PrintAssemblyOptions=hsdis-print-bytes</code> 额外输出指令实际字节序列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:PrintAssemblyOptions=hsdis-print-bytes Accumulator 50000</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre>Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional outputLoaded disassembler from hsdis-amd64.soDecoding compiled method 0x00007f482105ee50:Code:[Disassembling for mach='i386:x86-64'][Entry Point][Verified Entry Point][Constants]  # {method} 'sqrt' '(I)D' in 'Accumulator'  # parm0:    rsi       = int  #           [sp+0x20]  (sp of caller)  0x00007f482105ef80: sub    $0x18,%rsp         ;...4881ec18 000000  0x00007f482105ef87: mov    %rbp,0x10(%rsp)    ;...48896c24 10                                                ;*synchronization entry                                                ; - Accumulator::sqrt@-1 (line 20)  0x00007f482105ef8c: vcvtsi2sd %esi,%xmm0,%xmm0  ;...c5fb2ac6  0x00007f482105ef90: vsqrtsd %xmm0,%xmm0,%xmm0  ;...c5fb51c0                                                ;*invokestatic sqrt                                                ; - Accumulator::sqrt@2 (line 20)  0x00007f482105ef94: add    $0x10,%rsp         ;...4883c410  0x00007f482105ef98: pop    %rbp               ;...5d  0x00007f482105ef99: test   %eax,0xc048061(%rip)        # 0x00007f482d0a7000                                                ;...85056180 040c                                                ;   {poll_return}  0x00007f482105ef9f: retq                      ;...c3[Exception Handler][Stub Code]  0x00007f482105efa0: jmpq   0x00007f482105eda0  ;...e9fbfdff ff                                                ;   {no_reloc}[Deopt Handler Code]  0x00007f482105efa5: callq  0x00007f482105efaa  ;...e8000000 00  0x00007f482105efaa: subq   $0x5,(%rsp)        ;...48832c24 05  0x00007f482105efaf: jmpq   0x00007f4821038f00  ;...e94c9ffd ff                                                ;   {runtime_call}  0x00007f482105efb4: hlt                       ;...f4...</pre><p>上述命令总是输出所有方法的 JIT 结果，当结果很多时难以看出重点，可以将 <code>-XX:+PrintAssembly</code> 选项改为 <code>-XX:CompileCommand=print,*class.method</code> 来限制输出哪些方法，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:CompileCommand=<span class="string">&#x27;print,*Accumulator.sqrt&#x27;</span> Accumulator 50000</span><br></pre></td></tr></table></figure><p>这样输出结果就变得很少了：</p><pre>CompilerOracle: print *Accumulator.sqrtJava HotSpot(TM) 64-Bit Server VM warning: printing of assembly code is enabled; turning on DebugNonSafepoints to gain additional outputCompiled method (c2)      62    2             Accumulator::sqrt (6 bytes) total in heap  [0x00007fcacc1d18d0,0x00007fcacc1d1a98] = 456 relocation     [0x00007fcacc1d19f0,0x00007fcacc1d19f8] = 8 main code      [0x00007fcacc1d1a00,0x00007fcacc1d1a20] = 32 stub code      [0x00007fcacc1d1a20,0x00007fcacc1d1a38] = 24 oops           [0x00007fcacc1d1a38,0x00007fcacc1d1a40] = 8 scopes data    [0x00007fcacc1d1a40,0x00007fcacc1d1a50] = 16 scopes pcs     [0x00007fcacc1d1a50,0x00007fcacc1d1a90] = 64 dependencies   [0x00007fcacc1d1a90,0x00007fcacc1d1a98] = 8Loaded disassembler from hsdis-amd64.soDecoding compiled method 0x00007fcacc1d18d0:Code:[Disassembling for mach='i386:x86-64'][Entry Point][Verified Entry Point][Constants]  # {method} 'sqrt' '(I)D' in 'Accumulator'  # parm0:    rsi       = int  #           [sp+0x20]  (sp of caller)  0x00007fcacc1d1a00: sub    $0x18,%rsp  0x00007fcacc1d1a07: mov    %rbp,0x10(%rsp)    ;*synchronization entry                                                ; - Accumulator::sqrt@-1 (line 20)  0x00007fcacc1d1a0c: vcvtsi2sd %esi,%xmm0,%xmm0  0x00007fcacc1d1a10: vsqrtsd %xmm0,%xmm0,%xmm0  ;*invokestatic sqrt                                                ; - Accumulator::sqrt@2 (line 20)  0x00007fcacc1d1a14: add    $0x10,%rsp  0x00007fcacc1d1a18: pop    %rbp  0x00007fcacc1d1a19: test   %eax,0x9ea55e1(%rip)        # 0x00007fcad6077000                                                ;   {poll_return}  0x00007fcacc1d1a1f: retq[Exception Handler][Stub Code]  0x00007fcacc1d1a20: jmpq   0x00007fcacc1ceda0  ;   {no_reloc}[Deopt Handler Code]  0x00007fcacc1d1a25: callq  0x00007fcacc1d1a2a  0x00007fcacc1d1a2a: subq   $0x5,(%rsp)  0x00007fcacc1d1a2f: jmpq   0x00007fcacc1a8f00  ;   {runtime_call}  0x00007fcacc1d1a34: hlt  0x00007fcacc1d1a35: hlt  0x00007fcacc1d1a36: hlt  0x00007fcacc1d1a37: hltOopMapSet contains 0 OopMaps</pre><p><strong>Tips：</strong> 用如下命令能看到 JVM 支持的所有内部选项及其当前值，可以用于排查环境问题或进行细节调整：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+AggressiveOpts -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://www.slideshare.net/CharlesNutter/javaone-2012-jvm-jit-for-dummies">JVM JIT for Dummies</a></li><li><a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">HotSpotInternals - PrintAssembly</a></li><li><a href="http://stackoverflow.com/questions/9341083/how-to-use-xxunlockdiagnosticvmoptions-xxcompilecommand-print-option-with-j">How to use -XX:+UnlockDiagnosticVMOptions -XX:CompileCommand=print option with JVM HotSpot</a></li></ul><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><code>!</code> 表示是异常处理函数， <code>n</code> 表示是 native 函数， <code>%</code> 表示进行了 OSR（On-Stack Replace） 优化 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;大家都知道 JVM 有 HotSpot 引擎可以对热代码路径进行有效的 JIT 优化，大幅度提升计算密集代码的性能，但 HotSpot 对自己编写的 Java 代码时进行了哪些 JIT 优化？优化后生成的 native code 长什么样？知道了这些信息之后，才能有的放矢地改进自己的代码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://chaoslawful.info/tags/Java/"/>
    
    <category term="JIT" scheme="https://chaoslawful.info/tags/JIT/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 下用 adb 连接京崎 Tooky T85 手机</title>
    <link href="https://chaoslawful.info/2013/10/09/ubuntu-adb-connect-tooky-t85/"/>
    <id>https://chaoslawful.info/2013/10/09/ubuntu-adb-connect-tooky-t85/</id>
    <published>2013-10-09T14:35:00.000Z</published>
    <updated>2022-05-06T16:11:19.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取手机的-vendor-id"><a class="markdownIt-Anchor" href="#获取手机的-vendor-id"></a> 获取手机的 vendor id</h2><p>用 USB 线连接手机，执行 <code>lsusb</code> 命令后可以看到如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bus 001 Device 010: ID 4bb0:30d2</span><br></pre></td></tr></table></figure><p>那么 vendor id 就是 <code>0x4bb0</code></p><span id="more"></span><h2 id="增加识别手机设备的-udev-规则"><a class="markdownIt-Anchor" href="#增加识别手机设备的-udev-规则"></a> 增加识别手机设备的 udev 规则</h2><p>编辑 <code>/etc/udev/rules.d/51-android.rules</code> ，加入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==<span class="string">&quot;usb&quot;</span>, ATTRS&#123;idVendor&#125;==<span class="string">&quot;4bb0&quot;</span>, MODE=<span class="string">&quot;0666&quot;</span>, GROUP=<span class="string">&quot;plugdev&quot;</span></span><br></pre></td></tr></table></figure><p>这里 <code>ATTRS&#123;idVendor&#125;</code> 条件之后填的就是上面获得的 vendor id。</p><p>添加完毕后执行 <code>sudo reload udev</code> 重新加载新的 udev 规则，然后重新插拔一次手机</p><h2 id="让-adb-识别手机设备"><a class="markdownIt-Anchor" href="#让-adb-识别手机设备"></a> 让 adb 识别手机设备</h2><p>做完以上步骤后 <code>adb devices</code> 仍然不能识别手机，因为京崎的 vendor id 并没有放在 Android SDK 的默认厂商列表中。</p><p>这里需要修改 <code>~/.android/adb_usb.ini</code> ，在最末尾增加 16 进制格式的 vendor id，这里增加后的内容就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ANDROID 3RD PARTY USB VENDOR ID LIST -- DO NOT EDIT.</span></span><br><span class="line"><span class="comment"># USE &#x27;android update adb&#x27; TO GENERATE.</span></span><br><span class="line"><span class="comment"># 1 USB VENDOR ID PER LINE.</span></span><br><span class="line"></span><br><span class="line">0x4bb0</span><br></pre></td></tr></table></figure><p>注意运行 <code>android update adb</code> 会清空该文件，慎用此命令！</p><p>最后执行如下命令重启 adb server 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server</span><br><span class="line">adb start-server</span><br><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>看到 <code>adb devices</code> 显示如下字样就是成功了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">0123456789ABCDEFdevice</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;获取手机的-vendor-id&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#获取手机的-vendor-id&quot;&gt;&lt;/a&gt; 获取手机的 vendor id&lt;/h2&gt;
&lt;p&gt;用 USB 线连接手机，执行 &lt;code&gt;lsusb&lt;/code&gt; 命令后可以看到如下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Bus 001 Device 010: ID 4bb0:30d2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么 vendor id 就是 &lt;code&gt;0x4bb0&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://chaoslawful.info/tags/Android/"/>
    
    <category term="Tooky" scheme="https://chaoslawful.info/tags/Tooky/"/>
    
  </entry>
  
  <entry>
    <title>完整的 chroot 过程</title>
    <link href="https://chaoslawful.info/2013/09/10/complete-chroot/"/>
    <id>https://chaoslawful.info/2013/09/10/complete-chroot/</id>
    <published>2013-09-10T06:22:00.000Z</published>
    <updated>2022-05-06T16:11:35.007Z</updated>
    
    <content type="html"><![CDATA[<p>直接简单地运行 <code>chroot &lt;new-root-dir&gt;</code> 不足以正常运行一些程序，因为很多程序需要访问 <code>procfs</code> 、 <code>sysfs</code> 、 <code>devfs</code> 等特殊的子目录，直接 <code>chroot</code> 更改根目录后这些子目录没有被挂载，内容都是空，导致这些程序出现问题。</p><span id="more"></span><p>完整的 <code>chroot</code> 前准备过程可以通过下列命令完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;new-root-dir&gt;</span><br><span class="line">mount -t proc proc proc/</span><br><span class="line">mount -t sysfs sys sys/</span><br><span class="line">mount -o <span class="built_in">bind</span> /dev dev/</span><br><span class="line">mount -t devpts pts dev/pts/</span><br><span class="line"><span class="built_in">cp</span> -L /etc/resolv.conf etc/resolv.conf</span><br></pre></td></tr></table></figure><p>上述命令将宿主系统的 <code>procfs</code> 、 <code>sysfs</code> 、 <code>devfs</code> 等特殊目录挂载到新的根目录下对应子目录上，并设置 <code>chroot</code> 系统使用宿主系统的域名解析配置，最后用以下命令即可完成 <code>chroot</code> 操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> &lt;new-root-dir&gt; /bin/bash</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://wiki.archlinux.org/index.php/Change_Root">https://wiki.archlinux.org/index.php/Change_Root</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;直接简单地运行 &lt;code&gt;chroot &amp;lt;new-root-dir&amp;gt;&lt;/code&gt; 不足以正常运行一些程序，因为很多程序需要访问 &lt;code&gt;procfs&lt;/code&gt; 、 &lt;code&gt;sysfs&lt;/code&gt; 、 &lt;code&gt;devfs&lt;/code&gt; 等特殊的子目录，直接 &lt;code&gt;chroot&lt;/code&gt; 更改根目录后这些子目录没有被挂载，内容都是空，导致这些程序出现问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://chaoslawful.info/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>科技文献中常见的数词来源</title>
    <link href="https://chaoslawful.info/2013/09/04/science-numeral-etymology/"/>
    <id>https://chaoslawful.info/2013/09/04/science-numeral-etymology/</id>
    <published>2013-09-04T05:49:00.000Z</published>
    <updated>2022-05-06T16:11:49.237Z</updated>
    
    <content type="html"><![CDATA[<p>之前经常在科技文献中看到这些词的使用：</p><ul><li>表示数进制的：bin、oct、dec、hex ...</li><li>表示参数个数的：nullary、unary、binary、ternay ...</li><li>表示倍数的：single、double、triple、quadruple ...</li><li>表示优先级的：primary、secondary、tertiary ...</li><li>表示几何形状的：triangle、tetragon、pentagon、hexagon ...</li></ul><span id="more"></span><p>一直以来却不甚知道为什么用这些词来表达，其含义究竟是什么？最近研究了一番才了解到了一些端倪。大体上是因为现代科学基本上是从古希腊到古罗马一系传承下来的，其用语自然受到希腊语和拉丁语的影响，且由于各个学科门类的出现时间和跨度相差很大，往往会出现多种语源的词汇混合在一起使用的情形。</p><p>古希腊人爱好几何学研究，可以猜到几何形状的描述肯定是希腊词根了。而其他很多场景下用的则是拉丁词根或希腊/拉丁组合词根。下面是摘抄自 wikipedia 的一些数字词根：</p><ul><li>希腊语：</li></ul><table><thead><tr><th style="text-align:right"><strong>数值</strong></th><th style="text-align:left"><strong>表基数</strong></th><th style="text-align:left"><strong>表倍数</strong></th></tr></thead><tbody><tr><td style="text-align:right">1/2</td><td style="text-align:left">hemi-</td><td style="text-align:left">-</td></tr><tr><td style="text-align:right">1</td><td style="text-align:left">hen-</td><td style="text-align:left">mono-, haplo-</td></tr><tr><td style="text-align:right">2</td><td style="text-align:left">di-, dy-, duo-</td><td style="text-align:left">dis-</td></tr><tr><td style="text-align:right">3</td><td style="text-align:left">tri-</td><td style="text-align:left">tris-,</td></tr><tr><td style="text-align:right">4</td><td style="text-align:left">tetra-</td><td style="text-align:left">tetrakis-</td></tr><tr><td style="text-align:right">5</td><td style="text-align:left">penta-</td><td style="text-align:left">pentakis-</td></tr><tr><td style="text-align:right">6</td><td style="text-align:left">hexa-</td><td style="text-align:left">hexakis-</td></tr><tr><td style="text-align:right">7</td><td style="text-align:left">hepta-</td><td style="text-align:left">heptakis-</td></tr><tr><td style="text-align:right">8</td><td style="text-align:left">ogdo-, octa-, octo-</td><td style="text-align:left">octakis-</td></tr><tr><td style="text-align:right">9</td><td style="text-align:left">ennea-</td><td style="text-align:left">enneakis-</td></tr><tr><td style="text-align:right">10</td><td style="text-align:left">deca-</td><td style="text-align:left">decakis-</td></tr><tr><td style="text-align:right">16</td><td style="text-align:left">hexakaideca-, hexadeca-</td><td style="text-align:left">hexadecakis-</td></tr></tbody></table><ul><li>拉丁语：</li></ul><table><thead><tr><th style="text-align:right"><strong>数值</strong></th><th style="text-align:left"><strong>表基数</strong></th><th style="text-align:left"><strong>表倍数</strong></th><th style="text-align:left"><strong>表分配(即每多少个的意思)</strong></th><th style="text-align:left"><strong>表序数(即第多少个的意思)</strong></th></tr></thead><tbody><tr><td style="text-align:right">1/2</td><td style="text-align:left">semi-</td><td style="text-align:left">-</td><td style="text-align:left">demi-</td><td style="text-align:left">-</td></tr><tr><td style="text-align:right">1</td><td style="text-align:left">uni-</td><td style="text-align:left">sim-</td><td style="text-align:left">singul-</td><td style="text-align:left">prim-</td></tr><tr><td style="text-align:right">2</td><td style="text-align:left">du-</td><td style="text-align:left">bi-, bis-</td><td style="text-align:left">bin-</td><td style="text-align:left">second-</td></tr><tr><td style="text-align:right">3</td><td style="text-align:left">tri-</td><td style="text-align:left">ter-</td><td style="text-align:left">tern-, trin-</td><td style="text-align:left">terti-</td></tr><tr><td style="text-align:right">4</td><td style="text-align:left">quadri-, quadru-</td><td style="text-align:left">quater-</td><td style="text-align:left">quatern-</td><td style="text-align:left">quart-</td></tr><tr><td style="text-align:right">5</td><td style="text-align:left">quinque-</td><td style="text-align:left">-</td><td style="text-align:left">quin-</td><td style="text-align:left">quint-</td></tr><tr><td style="text-align:right">6</td><td style="text-align:left">sexa-</td><td style="text-align:left">-</td><td style="text-align:left">sen-</td><td style="text-align:left">sext-</td></tr><tr><td style="text-align:right">7</td><td style="text-align:left">septem-, septi-</td><td style="text-align:left">septem-, septi-</td><td style="text-align:left">septen-</td><td style="text-align:left">septim-</td></tr><tr><td style="text-align:right">8</td><td style="text-align:left">octo-</td><td style="text-align:left">-</td><td style="text-align:left">octon-</td><td style="text-align:left">octav-</td></tr><tr><td style="text-align:right">9</td><td style="text-align:left">novem-</td><td style="text-align:left">novem-</td><td style="text-align:left">noven-</td><td style="text-align:left">nona-</td></tr><tr><td style="text-align:right">10</td><td style="text-align:left">decem-, dec-</td><td style="text-align:left">decem-, dec-</td><td style="text-align:left">den-</td><td style="text-align:left">decim-</td></tr><tr><td style="text-align:right">16</td><td style="text-align:left">sedec-, sexdec-</td><td style="text-align:left">sedec-, sexdec-</td><td style="text-align:left">sedec-, sexdec-</td><td style="text-align:left">sedec-, sexdec-</td></tr></tbody></table><p>从拉丁语词根里是不是看到了一些熟悉的东西？呵呵，电影里经常看到的半神 demigod 的 demi- 就是一半的意思，而英语里表达月份的名词实际上就是罗马人用拉丁语数第几个月了，不过个别月份为了纪念神明、节期或皇帝而变更了名称，且原始的罗马历法中一年只有 10 个月，现在的 3 月是当时的第一个月，12 月则是第十个月，漫长的冬日则认为无需计算月份，后来变更历法时才加入现在的 1 月和 2 月。各个月份名的含义如下：</p><table><thead><tr><th style="text-align:left"><strong>月份名称</strong></th><th style="text-align:left"><strong>含义</strong></th></tr></thead><tbody><tr><td style="text-align:left">January</td><td style="text-align:left">取自罗马神话中门神 Janus，表达一年开始的意思</td></tr><tr><td style="text-align:left">February</td><td style="text-align:left">取自拉丁语 februum (即净化)，因为这段时间内会举行传统的净化仪式</td></tr><tr><td style="text-align:left">March</td><td style="text-align:left">取自罗马神话中战神 Mars</td></tr><tr><td style="text-align:left">April</td><td style="text-align:left">可能源自拉丁语 aperire (即开放)，暗示这个季节树木花草都开始发芽，也可能取自希腊神话中美神 Aphrodite</td></tr><tr><td style="text-align:left">May</td><td style="text-align:left">取自希腊神话中女神 Maia</td></tr><tr><td style="text-align:left">June</td><td style="text-align:left">取自罗马神话中女神 Juno</td></tr><tr><td style="text-align:left">July</td><td style="text-align:left">本来叫 Quintillis (即第 5 个月，词根 quin-)，后为纪念皇帝 Julius Caesar 改名</td></tr><tr><td style="text-align:left">August</td><td style="text-align:left">本来叫 Sextillis (即第 6 个月，词根 sexa-)，后为纪念皇帝 Augustus 改名</td></tr><tr><td style="text-align:left">September</td><td style="text-align:left">即第 7 个月 (词根 septem-)</td></tr><tr><td style="text-align:left">October</td><td style="text-align:left">即第 8 个月 (词根 octo-)</td></tr><tr><td style="text-align:left">November</td><td style="text-align:left">即第 9 个月 (词根 novem-)</td></tr><tr><td style="text-align:left">December</td><td style="text-align:left">即第 10 个月 (词根 decem-)</td></tr></tbody></table><p>而计算机中常见的 NULL 或 NIL 则来自拉丁语 nulla 和 nil (表示什么都没有的意思)，不过 nil 在希腊语中也表达类似的意思。表达 16 进制的单词 hexadecimal 比较奇葩，是一个希腊/拉丁混合词，以前有人争论说应该改成纯拉丁词 senidenary 或 sedenary，后来也没能挡住习惯的力量。</p><p>参考：</p><ul><li><a href="http://en.wikipedia.org/wiki/Numeral_prefix">http://en.wikipedia.org/wiki/Numeral_prefix</a></li><li><a href="http://en.wikipedia.org/wiki/Arity">http://en.wikipedia.org/wiki/Arity</a></li><li><a href="http://en.wikipedia.org/wiki/List_of_numeral_systems">http://en.wikipedia.org/wiki/List_of_numeral_systems</a></li><li><a href="http://en.wikipedia.org/wiki/Hexadecimal#Etymology">http://en.wikipedia.org/wiki/Hexadecimal#Etymology</a></li><li><a href="http://en.wikipedia.org/wiki/Category:Months">http://en.wikipedia.org/wiki/Category:Months</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前经常在科技文献中看到这些词的使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示数进制的：bin、oct、dec、hex ...&lt;/li&gt;
&lt;li&gt;表示参数个数的：nullary、unary、binary、ternay ...&lt;/li&gt;
&lt;li&gt;表示倍数的：single、double、triple、quadruple ...&lt;/li&gt;
&lt;li&gt;表示优先级的：primary、secondary、tertiary ...&lt;/li&gt;
&lt;li&gt;表示几何形状的：triangle、tetragon、pentagon、hexagon ...&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="etymology" scheme="https://chaoslawful.info/tags/etymology/"/>
    
  </entry>
  
  <entry>
    <title>如何将 Python 模块打成 DEB/RPM 包</title>
    <link href="https://chaoslawful.info/2013/08/22/python-mod-package/"/>
    <id>https://chaoslawful.info/2013/08/22/python-mod-package/</id>
    <published>2013-08-22T04:34:00.000Z</published>
    <updated>2022-05-06T16:12:07.887Z</updated>
    
    <content type="html"><![CDATA[<p>Python 模块的安装可以用 easy_install 或 pip 方便地完成，但此类工具难以应用在生产系统的部署中。使用 DEB/RPM 包的好处是大规模部署简单、容易回滚且能以一致的方式管理依赖，所以需要将 Python 模块打成此类原生包。</p><span id="more"></span><p>打 RPM 包比较简单，现在的模块一般都是 setuptools 规范的，只要简单地进入模块源码目录，运行 <code>python setup.py bdist_rpm</code> 即可打出 RPM 包。</p><p>打 DEB 包需要 <a href="https://pypi.python.org/pypi/stdeb">stdeb</a> 工具的支持，安装该工具后可以用如下命令打出 DEB 包：</p><ul><li>下载要打的模块（假设为 uncertainties 模块）源码 tarball，可用命令 <code>pip install -d . uncertainties</code></li><li>假设源码包为 <code>uncertainties-2.4.1.tar.gz</code> ，执行 <code>py2dsc uncertainties-2.4.1.tar.gz</code> 将其转换为 Debian 源码包</li><li>进入 <code>py2dsc</code> 生成的打包目录打包：<ul><li><code>cd deb_dist/uncertainties-2.4.1/</code></li><li><code>dpkg-buildpackage -rfakeroot -uc -us</code></li></ul></li><li>生成的 DEB 包就在上级目录里</li></ul><p>如果只是想直接安装转换后的 DEB 包，则可以简单地用命令 <code>sudo pypi-install uncertainties</code> 完成，无需使用上面较麻烦的步骤。</p><p>参考：</p><ul><li><a href="https://pypi.python.org/pypi/stdeb">https://pypi.python.org/pypi/stdeb</a></li><li><a href="http://docs.python.org/2.0/dist/creating-rpms.html">http://docs.python.org/2.0/dist/creating-rpms.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python 模块的安装可以用 easy_install 或 pip 方便地完成，但此类工具难以应用在生产系统的部署中。使用 DEB/RPM 包的好处是大规模部署简单、容易回滚且能以一致的方式管理依赖，所以需要将 Python 模块打成此类原生包。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://chaoslawful.info/tags/Python/"/>
    
    <category term="deb" scheme="https://chaoslawful.info/tags/deb/"/>
    
    <category term="rpm" scheme="https://chaoslawful.info/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>org2blog 如何发布左对齐的 LaTeX 公式</title>
    <link href="https://chaoslawful.info/2013/08/14/org2blog-left-align-latex/"/>
    <id>https://chaoslawful.info/2013/08/14/org2blog-left-align-latex/</id>
    <published>2013-08-14T01:44:00.000Z</published>
    <updated>2022-05-06T16:12:24.877Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下 Wordpress 上的基于 MathJax 显示的 LaTeX 插件总是将独立公式显示为居中对齐的，但当文章中的公式都比较短时居中对齐就显得不太美观。若想让独立公式在文章中总是左对齐，可以在编辑 org2blog 内容时在正文开始前加入如下片段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><br><span class="line"><span class="title class_">MathJax</span>.<span class="property">Hub</span>.<span class="title class_">Config</span>(&#123;</span><br><span class="line">  <span class="attr">displayAlign</span>: <span class="string">&quot;left&quot;</span>,</span><br><span class="line">  <span class="attr">displayIndent</span>: <span class="string">&quot;2em&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><span id="more"></span><p>这里的 <code>displayIndent</code> 可以控制左对齐公式的缩进宽度，若设为 &quot;0&quot; 就表示同正文平齐。下面是具体的例子：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>x</mi><mtext> </mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_a^b x\,dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5990080000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><msup><mi mathvariant="normal">e</mi><mi>s</mi></msup><mi>x</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">f(x)=\int_{-\infty}^{+\infty}\mathrm{e}^s x\,\mathrm{d}s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">e</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">d</span></span><span class="mord mathdefault">s</span></span></span></span></span></p><p>P.S. 虽然 MathJax 支持直接识别很多 LaTeX 的环境块，但通常 Wordpress 上的 LaTeX 插件仅在检测到自己识别的 LaTeX 标签时才会生成加载 MathJax 的代码，如果 blog 中只使用了 LaTeX 环境块就会导致无法加载 MathJax 而全部显示为普通文本。解决方法是在正文某处显式写一个空内容的可识别 LaTeX 标签欺骗 LaTeX 插件加载 MathJax。</p><p>参考：<a href="https://github.com/mathjax/mathjax-docs/wiki/MathML-alignment-Left-or-Right">https://github.com/mathjax/mathjax-docs/wiki/MathML-alignment-Left-or-Right</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常情况下 Wordpress 上的基于 MathJax 显示的 LaTeX 插件总是将独立公式显示为居中对齐的，但当文章中的公式都比较短时居中对齐就显得不太美观。若想让独立公式在文章中总是左对齐，可以在编辑 org2blog 内容时在正文开始前加入如下片段：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&amp;quot;text/x-mathjax-config&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title class_&quot;&gt;MathJax&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;Hub&lt;/span&gt;.&lt;span class=&quot;title class_&quot;&gt;Config&lt;/span&gt;(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;displayAlign&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;left&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;displayIndent&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;2em&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Emacs" scheme="https://chaoslawful.info/tags/Emacs/"/>
    
    <category term="org2blog" scheme="https://chaoslawful.info/tags/org2blog/"/>
    
  </entry>
  
  <entry>
    <title>org2blog 发布语法高亮源码块的注意事项</title>
    <link href="https://chaoslawful.info/2013/08/09/org2blog-syntaxhighlight/"/>
    <id>https://chaoslawful.info/2013/08/09/org2blog-syntaxhighlight/</id>
    <published>2013-08-09T15:26:00.000Z</published>
    <updated>2022-05-06T16:12:38.487Z</updated>
    
    <content type="html"><![CDATA[<p>Org2blog 要在 Wordpress 中发布语法高亮的源码区块，需要做以下准备：</p><ul><li>Wordpress 中要安装 SyntaxHighlighter Evolved 插件</li><li>emacs 中添加设置以将 pre 区块转换为 sourcecode 区块以让语法高亮插件工作： <code>(setq org2blog/wp-use-sourcecode-shortcode t)</code></li></ul><span id="more"></span><p>最后，org2blog 依赖于 org-mode 的 HTML 导出功能，后者总是会转义所有 XML/HTML 特殊字符，但当前版本的 SyntaxHighlighter Evolved 插件也总是会转义这些符号，造成双重转义使高亮输出发生混乱。解决方式是修改 SyntaxHighlighter Evolved 插件，将 <code>syntaxhighlighter.php</code> 中的 <code>encode_shortcode_contents_callback()</code> 函数改为如下形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode_shortcode_contents_callback</span>(<span class="params"> <span class="variable">$atts</span>, <span class="variable">$code</span> = <span class="string">&#x27;&#x27;</span>, <span class="variable">$tag</span> = <span class="literal">false</span> </span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;encoded = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">XXX:</span> modified by wxz</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> === <span class="title function_ invoke__">strpos</span>(<span class="variable">$code</span>, <span class="string">&#x27;&lt;&#x27;</span>) &amp;&amp; <span class="literal">false</span> === <span class="title function_ invoke__">strpos</span>(<span class="variable">$code</span>, <span class="string">&#x27;&gt;&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// content already escaped</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// content not escaped yet</span></span><br><span class="line">        <span class="variable">$code</span> = <span class="title function_ invoke__">str_replace</span>( <span class="title function_ invoke__">array_keys</span>(<span class="variable">$this</span>-&gt;specialchars), <span class="title function_ invoke__">array_values</span>(<span class="variable">$this</span>-&gt;specialchars), <span class="title function_ invoke__">htmlspecialchars</span>( <span class="variable">$code</span> ) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">XXX:</span> ends here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span> . <span class="variable">$tag</span> . <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">atts2string</span>( <span class="variable">$atts</span> ) . <span class="string">&quot;]<span class="subst">&#123;$code&#125;</span>[/<span class="subst">$tag</span>]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以在源码区块内容已经转义的情况下不再进行二次转义，从而解决输出混乱问题。</p><p>下面是一个语法高亮的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Org2blog 要在 Wordpress 中发布语法高亮的源码区块，需要做以下准备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wordpress 中要安装 SyntaxHighlighter Evolved 插件&lt;/li&gt;
&lt;li&gt;emacs 中添加设置以将 pre 区块转换为 sourcecode 区块以让语法高亮插件工作： &lt;code&gt;(setq org2blog/wp-use-sourcecode-shortcode t)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Emacs" scheme="https://chaoslawful.info/tags/Emacs/"/>
    
    <category term="org2blog" scheme="https://chaoslawful.info/tags/org2blog/"/>
    
    <category term="org-mode" scheme="https://chaoslawful.info/tags/org-mode/"/>
    
  </entry>
  
  <entry>
    <title>编译 Java 程序时出现 code too large 错误的分析</title>
    <link href="https://chaoslawful.info/2013/08/08/code-too-large/"/>
    <id>https://chaoslawful.info/2013/08/08/code-too-large/</id>
    <published>2013-08-08T09:48:00.000Z</published>
    <updated>2022-05-06T16:13:12.377Z</updated>
    
    <content type="html"><![CDATA[<p>我参与的一个实际项目里用到了 ANTLR 3.x 进行 parser 代码自动生成，其中含有大量的 static field 用作状态转移查找表。由于一个 class 中所有 static field 都是放在一个匿名 method 中统一进行初始化，而 Java VM 规范规定一个 class 中单个 method 中 bytecode 长度最多不能超过 65535 bytes，这个自动生成的 parser class 始终无法在 javac 上编译，总是会提示 <code>error: code too large</code> 。但问题是在 Eclipse 中编译使用该文件完全没有问题，由于 65535 bytes 的限制是 Java VM 规范所规定，同生成 class 的编译器没有关系，因此原因只可能是 ecj 生成的 bytecode 比 javac 少，这就有点儿诡异了。</p><span id="more"></span><p>要查看 class 中的字节码可以用 <code>javap</code> 程序完成，通过下面的命令可以将有问题的 class （这里假设是 Test）的静态初始化匿名 method 中所有 bytecode 输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c Test | sed -ne <span class="string">&#x27;/static &#123;&#125;/,/return/ p&#x27;</span></span><br></pre></td></tr></table></figure><p>将 Test class 的 static field 用对分法逐渐裁剪到 javac 刚好能编译过去，然后用上述命令导出 javac 编译结果和 ecj 编译结果进行对比分析，果然发现了一些差异（测试代码可从<a href="/files/Test.java.gz">此处</a>下载）。</p><p>例如如下的这段 Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span>[][] FOLLOW_DEFAULT_in_table_option26937 =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">long</span>[][]&#123;<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">0x0000000000000000L</span>,<span class="number">0x0000000002000000L</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>由 ecj 编译产出的 bytecode 为：</p><table><thead><tr><th style="text-align:right"><strong>offset</strong></th><th style="text-align:left"><strong>bytecode</strong></th><th style="text-align:left"><strong>stack</strong> [before]-&gt;[after]</th></tr></thead><tbody><tr><td style="text-align:right">0</td><td style="text-align:left">iconst_1</td><td style="text-align:left">-&gt; 1</td></tr><tr><td style="text-align:right">1</td><td style="text-align:left">anewarray #idx</td><td style="text-align:left">count -&gt; arrayref</td></tr><tr><td style="text-align:right">4</td><td style="text-align:left">dup</td><td style="text-align:left">value -&gt; value, value</td></tr><tr><td style="text-align:right">5</td><td style="text-align:left">iconst_0</td><td style="text-align:left">-&gt; 0</td></tr><tr><td style="text-align:right">6</td><td style="text-align:left">iconst_2</td><td style="text-align:left">-&gt; 2</td></tr><tr><td style="text-align:right">7</td><td style="text-align:left">newarray long</td><td style="text-align:left">count -&gt; arrayref</td></tr><tr><td style="text-align:right">9</td><td style="text-align:left">dup</td><td style="text-align:left">value -&gt; value, value</td></tr><tr><td style="text-align:right">10</td><td style="text-align:left">iconst_1</td><td style="text-align:left">-&gt; 1</td></tr><tr><td style="text-align:right">11</td><td style="text-align:left">ldc2_w #idx</td><td style="text-align:left">-&gt; value</td></tr><tr><td style="text-align:right">14</td><td style="text-align:left">lastore</td><td style="text-align:left">arrayref, index, value -&gt;</td></tr><tr><td style="text-align:right">15</td><td style="text-align:left">aastore</td><td style="text-align:left">arrayref, index, value -&gt;</td></tr><tr><td style="text-align:right">16</td><td style="text-align:left">pustatic #idx</td><td style="text-align:left">value -&gt;</td></tr></tbody></table><p>由 javac 编译产出的 bytecode 为：</p><table><thead><tr><th style="text-align:right"><strong>offset</strong></th><th style="text-align:left"><strong>bytecode</strong></th><th style="text-align:left"><strong>stack</strong> [before]-&gt;[after]</th></tr></thead><tbody><tr><td style="text-align:right">0</td><td style="text-align:left">iconst_1</td><td style="text-align:left">-&gt; 1</td></tr><tr><td style="text-align:right">1</td><td style="text-align:left">anewarray #idx</td><td style="text-align:left">count -&gt; arrayref</td></tr><tr><td style="text-align:right">4</td><td style="text-align:left">dup</td><td style="text-align:left">value -&gt; value, value</td></tr><tr><td style="text-align:right">5</td><td style="text-align:left">iconst_0</td><td style="text-align:left">-&gt; 0</td></tr><tr><td style="text-align:right">6</td><td style="text-align:left">iconst_2</td><td style="text-align:left">-&gt; 2</td></tr><tr><td style="text-align:right">7</td><td style="text-align:left">newarray long</td><td style="text-align:left">count -&gt; arrayref</td></tr><tr><td style="text-align:right">9</td><td style="text-align:left">dup</td><td style="text-align:left">value -&gt; value, value</td></tr><tr><td style="text-align:right">10</td><td style="text-align:left">iconst_0</td><td style="text-align:left">-&gt; 0</td></tr><tr><td style="text-align:right">11</td><td style="text-align:left">iconst_0</td><td style="text-align:left">-&gt; 0</td></tr><tr><td style="text-align:right">12</td><td style="text-align:left">lastore</td><td style="text-align:left">arrayref, index, value -&gt;</td></tr><tr><td style="text-align:right">13</td><td style="text-align:left">dup</td><td style="text-align:left">value -&gt; value, value</td></tr><tr><td style="text-align:right">14</td><td style="text-align:left">iconst_1</td><td style="text-align:left">-&gt; 1</td></tr><tr><td style="text-align:right">15</td><td style="text-align:left">ldc2_w #idx</td><td style="text-align:left">-&gt; value</td></tr><tr><td style="text-align:right">18</td><td style="text-align:left">lastore</td><td style="text-align:left">arrayref, index, value -&gt;</td></tr><tr><td style="text-align:right">19</td><td style="text-align:left">aastore</td><td style="text-align:left">arrayref, index, value -&gt;</td></tr><tr><td style="text-align:right">20</td><td style="text-align:left">pustatic #idx</td><td style="text-align:left">value -&gt;</td></tr></tbody></table><p>可以看到 javac 多生成了 offset 10~13 的 bytecode，分析可知这段代码的功能是将内部 long[] 数组第一个元素置为 0。也就是说，ecj 利用了 Java VM 规范中的默认初始化约定，不会为显式初始化为 0 的元素生成赋值 bytecode，但 javac 却会傻傻地按照初始化列表逐个生成 bytecode。这样当非 0 元素初始化很少时，ecj 就比 javac 生成的静态初始化 bytecode 少得多了，自然会发生 javac 编译报 code too large 错误但 ecj 正常的情况。</p><p>不过从另一方面看，ANTLR 3.x 生成的 parser 代码也确实没有考虑 Java VM 的 bytecode 长度限制，一旦语法复杂到一定程度，生成的代码很可能连 ecj 都无法编译通过。这是一个比较严重的设计疏忽，希望 ANTLR 后续版本使用变通方法对这一点进行改进。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</a></li><li><a href="http://marxsoftware.blogspot.com/2010/01/reproducing-code-too-large-problem-in.html">http://marxsoftware.blogspot.com/2010/01/reproducing-code-too-large-problem-in.html</a></li><li><a href="http://stackoverflow.com/questions/243097/javac-error-code-too-large">http://stackoverflow.com/questions/243097/javac-error-code-too-large</a></li><li><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6</a></li><li><a href="http://www.certpal.com/blogs/2009/08/code-too-large-for-try-statement/">http://www.certpal.com/blogs/2009/08/code-too-large-for-try-statement/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我参与的一个实际项目里用到了 ANTLR 3.x 进行 parser 代码自动生成，其中含有大量的 static field 用作状态转移查找表。由于一个 class 中所有 static field 都是放在一个匿名 method 中统一进行初始化，而 Java VM 规范规定一个 class 中单个 method 中 bytecode 长度最多不能超过 65535 bytes，这个自动生成的 parser class 始终无法在 javac 上编译，总是会提示 &lt;code&gt;error: code too large&lt;/code&gt; 。但问题是在 Eclipse 中编译使用该文件完全没有问题，由于 65535 bytes 的限制是 Java VM 规范所规定，同生成 class 的编译器没有关系，因此原因只可能是 ecj 生成的 bytecode 比 javac 少，这就有点儿诡异了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://chaoslawful.info/tags/Java/"/>
    
    <category term="Eclipse" scheme="https://chaoslawful.info/tags/Eclipse/"/>
    
    <category term="ANTLR" scheme="https://chaoslawful.info/tags/ANTLR/"/>
    
  </entry>
  
  <entry>
    <title>在使用 Ecipse Compiler 的 Maven 项目中如何使用 Lombok</title>
    <link href="https://chaoslawful.info/2013/08/08/ecj-lombok/"/>
    <id>https://chaoslawful.info/2013/08/08/ecj-lombok/</id>
    <published>2013-08-08T03:10:00.000Z</published>
    <updated>2022-05-06T16:12:57.647Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://projectlombok.org/">Lombok</a> 借助 javac 的内部 API 介入 annotation 处理环节，并根据其特有的 annotation 在编译期生成代码，能够大大简化 Java 代码很多冗余的写法。但正是因为其依赖于 javac 内部 API，Lombok 很难在其他 Java 编译器上使用，例如常用的替代编译器 Eclipse Compiler (ecj) 就是如此。</p><span id="more"></span><p>为了在非 javac 编译器上也能享受 Lombok 带来的好处，一个可能的方案是实际编译之前先借助 javac 的内部运行时库对 Java 代码进行 delombok 操作，即将被 Lombok 修改后的 Java 代码导出成实际文件，再使用 Eclipse Compiler 这样的替代编译器对导出代码进行真正的编译操作。方法如下：</p><ul><li>先让 Maven 项目在编译前预先执行 delombok 操作，修改 <code>pom.xml</code> 增加如下内容：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!-- 设置 delombok 展开后代码放置位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>target/generated-sources/delombok<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>target/generated-test-sources/delombok<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>delombok<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">addOutputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>test-delombok<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testDelombok<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">addOutputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/test/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sun.jdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/../lib/tools.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果 Maven 项目还没有使用 Eclipse Compiler，则还要修改 <code>pom.xml</code> 以启用它：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">compilerId</span>&gt;</span>eclipse<span class="tag">&lt;/<span class="name">compilerId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.plexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>plexus-compiler-eclipse<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>经过以上配置之后，Maven 项目的实际和测试 Java 代码中即可正常使用 Lombok annotation，也可以在 <code>mvn compile</code> 之后进入 <code>target/generated-sources/delombok/</code> 和 <code>target/generated-test-sources/delombok/</code> 目录自行查看被 Lombok 修改后的实际和测试代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://projectlombok.org/&quot;&gt;Lombok&lt;/a&gt; 借助 javac 的内部 API 介入 annotation 处理环节，并根据其特有的 annotation 在编译期生成代码，能够大大简化 Java 代码很多冗余的写法。但正是因为其依赖于 javac 内部 API，Lombok 很难在其他 Java 编译器上使用，例如常用的替代编译器 Eclipse Compiler (ecj) 就是如此。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://chaoslawful.info/tags/Java/"/>
    
    <category term="Lombok" scheme="https://chaoslawful.info/tags/Lombok/"/>
    
    <category term="Maven" scheme="https://chaoslawful.info/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>使用 Terratec Cinergy T Stick+ DVB 电视卡进行 RTL-SDR 实验时的几点注意事项</title>
    <link href="https://chaoslawful.info/2013/06/18/terratec-dvb-rtl-sdr/"/>
    <id>https://chaoslawful.info/2013/06/18/terratec-dvb-rtl-sdr/</id>
    <published>2013-06-17T16:12:00.000Z</published>
    <updated>2022-05-04T10:00:49.928Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Terratec Cinergy T Stick+ 相关驱动仅在 kernel 3.7 及以上版本中并入了主干<ul><li>使用之前版本内核的同学需要自行从 <code>git://linuxtv.org/media_build.git</code> 检出代码编译安装驱动模块</li><li>详情见 <a href="http://www.linuxtv.org/wiki/index.php/TerraTec_Cinergy_T_Stick%2B">http://www.linuxtv.org/wiki/index.php/TerraTec_Cinergy_T_Stick%2B</a></li></ul></li><li>安装 rtl-sdr 工具后，请确保 <code>/etc/udev/rules.d/</code> 中增加了其给出的 udev 规则以对设备结点权限进行修正，否则只有 root 才能访问 DVB 设备</li><li>使用 rtl-sdr 等 SDR 工具前，需要将自动加载的 dvb_usb_rtl28xxu 模块卸载，否则 SDR 相关工具会无法打开 DVB 设备并报错，建议检出最新版 rtl-sdr 代码并使用 <code>--enable-driver-detach</code> 选项配置后编译安装，这样 rtl-sdr 工具一旦发现设备被该模块占用便会将其自动卸载。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Terratec Cinergy T Stick+ 相关驱动仅在 kernel 3.7 及以上版本中并入了主干
&lt;ul&gt;
&lt;li&gt;使用之前版本内核的同学需要自行从 &lt;code&gt;git://linuxtv.org/media_build.git&lt;/code&gt; 检出</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://chaoslawful.info/tags/Linux/"/>
    
    <category term="SDR" scheme="https://chaoslawful.info/tags/SDR/"/>
    
  </entry>
  
  <entry>
    <title>对 GNUCash 进行的一点儿改进</title>
    <link href="https://chaoslawful.info/2012/11/27/gnucash-improv/"/>
    <id>https://chaoslawful.info/2012/11/27/gnucash-improv/</id>
    <published>2012-11-26T16:40:00.000Z</published>
    <updated>2022-05-06T16:13:33.287Z</updated>
    
    <content type="html"><![CDATA[<p>当前版本的 GNUCash 在连接 MySQL 数据库时有个比较严重的字符编码问题：为了兼容 Unicode 字符，GNUCash 在 <code>gnc_dbi_mysql_session_begin()</code> 函数中主动执行 <code>SET NAMES 'utf8'</code> 语句设定 MySQL 连接字符编码为 UTF-8，但遗憾的是用来在连接故障时修复连接的 <code>gnc_dbi_verify_conn()</code> 函数并没有进行类似的操作。一旦数据库连接因网络问题意外断开，用户输入新交易时就会使用 <code>gnc_dbi_verify_conn()</code> 重新创建的新连接，而该连接的字符编码是默认的 latin1，直接后果就是输入中文等字符都变成了一堆乱码。</p><span id="more"></span><p>实际上 GNUCash 底层使用的 libdbi 库是考虑了连接字符编码问题的，其专门提供了一个 &quot;encoding&quot; 的设置选项用来对连接字符编码进行通用设置，底层的各个 driver 在创建连接时都会尊重该设置。所以只要简单地增加该选项，不管连接怎么断开重连，字符编码都能保持正常。</p><p>打上附件中的 fix_charset.patch 就可以修正此问题了。</p><p>另外，General Ledger 功能实际上非常好用，有了它就不需要在各个 Account 之间来回切换查帐了。但 GNUCash 目前默认在 General Ledger 中只显示最近一个月的交易，可苦了想对更老交易对账的用户。</p><p>我对其进行了小小的修改，打上附件中的 enh_general_ledger.patch 即可让 General Ledger 显示当前年度的所有交易，这样对账就非常方便了。</p><p><strong>更新：</strong> 最近发现 General Ledger 实际上可以自定义显示日期范围，只要在进入 General Ledger 界面后选择菜单上的 View/Filter...，即可在弹出对话框的 Date 页选择显示起止日期，无需使用附件中的补丁。</p><ul><li><a href="/files/fix_charset.patch.gz">修正数据库连接断开重连后字符编码错误的补丁</a></li><li><a href="/files/enh_general_ledger.patch.gz">让 General Ledger 显示当前年度所有交易的补丁</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;当前版本的 GNUCash 在连接 MySQL 数据库时有个比较严重的字符编码问题：为了兼容 Unicode 字符，GNUCash 在 &lt;code&gt;gnc_dbi_mysql_session_begin()&lt;/code&gt; 函数中主动执行 &lt;code&gt;SET NAMES &#39;utf8&#39;&lt;/code&gt; 语句设定 MySQL 连接字符编码为 UTF-8，但遗憾的是用来在连接故障时修复连接的 &lt;code&gt;gnc_dbi_verify_conn()&lt;/code&gt; 函数并没有进行类似的操作。一旦数据库连接因网络问题意外断开，用户输入新交易时就会使用 &lt;code&gt;gnc_dbi_verify_conn()&lt;/code&gt; 重新创建的新连接，而该连接的字符编码是默认的 latin1，直接后果就是输入中文等字符都变成了一堆乱码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://chaoslawful.info/tags/Linux/"/>
    
    <category term="GNUCash" scheme="https://chaoslawful.info/tags/GNUCash/"/>
    
    <category term="patch" scheme="https://chaoslawful.info/tags/patch/"/>
    
  </entry>
  
  <entry>
    <title>修复 GNUCash 数据库中的乱码</title>
    <link href="https://chaoslawful.info/2012/11/18/gnucash-repair-malformed-str/"/>
    <id>https://chaoslawful.info/2012/11/18/gnucash-repair-malformed-str/</id>
    <published>2012-11-17T17:58:00.000Z</published>
    <updated>2022-05-04T10:00:49.928Z</updated>
    
    <content type="html"><![CDATA[<p>GNUCash 是一款很好的记账软件，但在使用 MySQL 作为存储后端时，由于其对连接字符集的设置有漏洞，容易出现记账备注中的中文变乱码的情况。此时，可以在 MySQL 中执行如下 SQL 语句完成修复工作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> splits <span class="keyword">SET</span> memo <span class="operator">=</span> <span class="keyword">CONVERT</span>(<span class="type">BINARY</span>(<span class="keyword">CONVERT</span>(memo <span class="keyword">USING</span> latin1)) <span class="keyword">USING</span> utf8) <span class="keyword">WHERE</span> <span class="keyword">CHAR_LENGTH</span>(<span class="keyword">CONVERT</span>(<span class="type">BINARY</span>(<span class="keyword">CONVERT</span>(memo <span class="keyword">USING</span> latin1)) <span class="keyword">USING</span> utf8)) <span class="operator">!=</span> <span class="keyword">CHAR_LENGTH</span>(memo);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GNUCash 是一款很好的记账软件，但在使用 MySQL 作为存储后端时，由于其对连接字符集的设置有漏洞，容易出现记账备注中的中文变乱码的情况。此时，可以在 MySQL 中执行如下 SQL 语句完成修复工作：&lt;/p&gt;
&lt;figure class=&quot;highlight sq</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://chaoslawful.info/tags/Linux/"/>
    
    <category term="GNUCash" scheme="https://chaoslawful.info/tags/GNUCash/"/>
    
  </entry>
  
</feed>
